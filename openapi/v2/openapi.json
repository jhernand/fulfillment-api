{
  "swagger": "2.0",
  "info": {
    "title": "Fulfillment API",
    "version": "0.0.1",
    "contact": {
      "name": "Innabox project",
      "url": "https://github.com/innabox"
    },
    "license": {
      "name": "Apache-2.0",
      "url": "https://github.com/innabox/fulfillment-api/blob/main/LICENSE"
    }
  },
  "tags": [
    {
      "name": "Events"
    },
    {
      "name": "ClusterOrders"
    },
    {
      "name": "ClusterTemplates"
    },
    {
      "name": "Clusters"
    },
    {
      "name": "HostClasses"
    }
  ],
  "schemes": [
    "https"
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/api/events/v1/events": {
      "get": {
        "summary": "Start watching events.",
        "description": "Note that the server doesn't make any guarantee about the delivery or order of these events. In particular events\nthat happen while the client is disconnected will not be delivered. Clients should consider using other mechanisms\nto ensure that they process objects correctly. For example, they can combine this watch mechanism with periodic\nredconciliation of all the objects.",
        "operationId": "Events_Watch",
        "responses": {
          "200": {
            "description": "A successful response.(streaming responses)",
            "schema": {
              "type": "object",
              "properties": {
                "result": {
                  "$ref": "#/definitions/v1EventsWatchResponse"
                },
                "error": {
                  "$ref": "#/definitions/rpcStatus"
                }
              },
              "title": "Stream result of v1EventsWatchResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "filter",
            "description": "Filter criteria.\n\nThe value of this parameter is a [CEL](https://cel.dev) boolean expression. The `event` variable will contain the\nfields of the event. If the result of the expression is `true` then the event will be sent by the server. For\nexample, to receive only the events that indicate that a cluster order has been modified and is now in the\nfulfilled state:\n\n```\nevent.type == EVENT_TYPE_OBJECT_CREATED \u0026\u0026 event.cluster_order.status.state == CLUSTER_ORDER_STATE_FULFILLED\n```\n\nIf this isn't provided, or if the value is empty, then all the events that the user has permission to see will be\nsent by the server.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Events"
        ]
      }
    },
    "/api/fulfillment/v1/cluster_orders": {
      "get": {
        "summary": "Retrieves the list of cluster orders.",
        "operationId": "ClusterOrders_List",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ClusterOrdersListResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "offset",
            "description": "Index of the first result. If not specified the default value will be zero.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "limit",
            "description": "Maximum number of results to be returned by the server. When not specified all the results will be returned. Note\nthat there may not be enough results to return, and that the server may decide, for performance reasons, to return\nless results than requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "filter",
            "description": "Filter criteria.\n\nThe syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names\nof the attributes of the order instead of the names of the columns of a table. For example, in order to retrieve\nall the orders with state `FULFILLED` the value should be:\n\n    state = 'FULLFILLED'\n\nIf this isn't provided, or if the value is empty, then all the orders that the user has permission to see will be\nreturned.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "order",
            "description": "Order criteria.\n\nThe syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the\nnames of the attributes of the order instead of the names of the columns of a table. For example, in order to sort\nthe orders descending by state the value should be:\n\n    state desc\n\nIf the parameter isn't provided, or if the value is empty, then the order of the results is undefined.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "ClusterOrders"
        ]
      },
      "post": {
        "summary": "Creates a new cluster order.",
        "operationId": "ClusterOrders_Create",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1ClusterOrder"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "object",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1ClusterOrder"
            }
          }
        ],
        "tags": [
          "ClusterOrders"
        ]
      }
    },
    "/api/fulfillment/v1/cluster_orders/{id}": {
      "get": {
        "summary": "Retrieves the details of one specific cluster order.",
        "operationId": "ClusterOrders_Get",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1ClusterOrder"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "ClusterOrders"
        ]
      },
      "delete": {
        "summary": "Delete a cluster order.",
        "operationId": "ClusterOrders_Delete",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ClusterOrdersDeleteResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "ClusterOrders"
        ]
      }
    },
    "/api/fulfillment/v1/cluster_orders/{object.id}": {
      "patch": {
        "summary": "Updates an existing cluster order.",
        "description": "In the HTTP+JSON version of the API this is mapped to the `PATCH` verb and the `update_mask` field is automatically\npopulated from the list of fields present in the request body. For example, to update the `state` of an order to\n`FULFILLED` the request line should be like this:\n\n```http\nPATCH /api/fulfillment/v1/cluster_orders/123\n```\n\nAnd the request body should be like this:\n\n```json\n{\n  \"status\": {\n    \"state\": \"CLUSTER_ORDER_STATE_FULFILLED\"\n  }\n}\n```\n\nThe response body will contain the modified object.",
        "operationId": "ClusterOrders_Update",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1ClusterOrder"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "object.id",
            "description": "Unique identifier of the order.\n\nThis will be automatically generated by the system when the order is placed.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "object",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "metadata": {
                  "$ref": "#/definitions/v1Metadata"
                },
                "spec": {
                  "$ref": "#/definitions/v1ClusterOrderSpec"
                },
                "status": {
                  "$ref": "#/definitions/v1ClusterOrderStatus"
                }
              },
              "description": "Contains the details that the user provides to request the provisioning of a cluster, as well as the current status\nof the order provided by the system."
            }
          }
        ],
        "tags": [
          "ClusterOrders"
        ]
      }
    },
    "/api/fulfillment/v1/cluster_templates": {
      "get": {
        "summary": "Retrieves the list of cluster templates.",
        "operationId": "ClusterTemplates_List",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ClusterTemplatesListResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "offset",
            "description": "Index of the first result. If not specified the default value will be zero.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "limit",
            "description": "Maximum number of results to be returned by the server. When not specified all the results will be returned. Note\nthat there may not be enough results to return, and that the server may decide, for performance reasons, to return\nless results than requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "filter",
            "description": "Filter criteria.\n\nThe syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names\nof the attributes of the template instead of the names of the columns of a table. For example, in order to retrieve\nall the templates with a title starting with `large` the value should be:\n\n    title like 'large%'\n\nIf this isn't provided, or if the value is empty, then all the templates that the user has permission to see will\nbe returned.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "order",
            "description": "Order criteria.\n\nThe syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the\nnames of the attributes of the templated instead of the names of the columns of a table. For example, in order to\nsort the templates descending by title the value should be:\n\n    name desc\n\nIf the parameter isn't provided, or if the value is empty, then the order of the results is undefined.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "ClusterTemplates"
        ]
      },
      "post": {
        "summary": "Creates a new cluster template.",
        "operationId": "ClusterTemplates_Create",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1ClusterTemplate"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "object",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1ClusterTemplate"
            }
          }
        ],
        "tags": [
          "ClusterTemplates"
        ]
      }
    },
    "/api/fulfillment/v1/cluster_templates/{id}": {
      "get": {
        "summary": "Retrieves the details of one specific cluster template.",
        "operationId": "ClusterTemplates_Get",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1ClusterTemplate"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "ClusterTemplates"
        ]
      },
      "delete": {
        "summary": "Delete a cluster template.",
        "operationId": "ClusterTemplates_Delete",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ClusterTemplatesDeleteResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "ClusterTemplates"
        ]
      }
    },
    "/api/fulfillment/v1/cluster_templates/{object.id}": {
      "patch": {
        "summary": "Updates an existint cluster template.",
        "operationId": "ClusterTemplates_Update",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1ClusterTemplate"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "object.id",
            "description": "Unique identifier of the template.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "object",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "metadata": {
                  "$ref": "#/definitions/v1Metadata"
                },
                "title": {
                  "type": "string",
                  "description": "Human friendly short description of the template, only a few words, suitable for displaying in one single\nline on a UI or CLI."
                },
                "description": {
                  "type": "string",
                  "description": "Human friendly long description of the template, using Markdown format."
                },
                "parameters": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "$ref": "#/definitions/v1ClusterTemplateParameterDefinition"
                  },
                  "description": "Definitions of the parameters that can be used to customize the template.\n\nNote that these are only the *definitions* of the parameters, not the actual values. The actual values are in the\n`spec.template_parameters` field of the cluster order."
                }
              },
              "description": "A cluster template defines a type of cluster that can be ordered by the user. Note that the user doesn't create these\ntemplates: the system provides a collection of them, and the user chooses one."
            }
          }
        ],
        "tags": [
          "ClusterTemplates"
        ]
      }
    },
    "/api/fulfillment/v1/clusters": {
      "get": {
        "summary": "Retrieves the list of clusters.",
        "operationId": "Clusters_List",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ClustersListResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "offset",
            "description": "Index of the first result. If not specified the default value will be zero.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "limit",
            "description": "Maximum number of results to be returned by the server. When not specified all the results will be returned. Note\nthat there may not be enough results to return, and that the server may decide, for performance reasons, to return\nless results than requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "filter",
            "description": "Filter criteria.\n\nThe syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names\nof the attributes of the cluster instead of the names of the columns of a table. For example, in order to retrieve\nall the cluster with a API URL starting with `http:` the value should be:\n\n    api_url like 'http:%'\n\nIf this isn't provided, or if the value is empty, then all the clusters that the user has permission to see will be\nreturned.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "order",
            "description": "Order criteria.\n\nThe syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the\nnames of the attributes of the cluster instead of the names of the columns of a table. For example, in order to\nsort the clusters descending by API URL the value should be:\n\n    api_url desc\n\nIf the parameter isn't provided, or if the value is empty, then the order of the results is undefined.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Clusters"
        ]
      },
      "post": {
        "summary": "Creates a new cluster.",
        "description": "Note that this operation is not allowed for regular users, only for the server. Regular users create clusters\nindirectly, creating a cluster order that will eventually result in the system creating a cluster.",
        "operationId": "Clusters_Create",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1Cluster"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "object",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1Cluster"
            }
          }
        ],
        "tags": [
          "Clusters"
        ]
      }
    },
    "/api/fulfillment/v1/clusters/{id}": {
      "get": {
        "summary": "Retrieves the details of one specific cluster.",
        "operationId": "Clusters_Get",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1Cluster"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Clusters"
        ]
      },
      "delete": {
        "summary": "Delete a cluster.",
        "operationId": "Clusters_Delete",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ClustersDeleteResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Clusters"
        ]
      }
    },
    "/api/fulfillment/v1/clusters/{id}/kubeconfig": {
      "get": {
        "summary": "Returns the admin Kubeconfig of the cluster.",
        "description": "This is intended for use with HTTP and returns the YAML text of the Kubeconfig directly using the content type\n`application/yaml`.\n\nbuf:lint:ignore RPC_RESPONSE_STANDARD_NAME",
        "operationId": "Clusters_GetKubeconfigViaHttp",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiHttpBody"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Clusters"
        ]
      }
    },
    "/api/fulfillment/v1/clusters/{object.id}": {
      "patch": {
        "summary": "Updates an existing cluster.",
        "description": "In the HTTP+JSON version of the API this is mapped to the `PATCH` verb and the `update_mask` field is automatically\npopulated from the list of fields present in the request body. For example, to update the `state` of a cluster to\n`READY` the request line should be like this:\n\n```http\nPATCH /api/fulfillment/v1/clusters/123\n```\n\nAnd the request body should be like this:\n\n```json\n{\n  \"status\": {\n    \"state\": \"CLUSTER_STATE_READY\"\n  }\n}\n```\n\nThe response body will contain the modified object.",
        "operationId": "Clusters_Update",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1Cluster"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "object.id",
            "description": "Unique identifier of the cluster.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "object",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "metadata": {
                  "$ref": "#/definitions/v1Metadata"
                },
                "spec": {
                  "$ref": "#/definitions/v1ClusterSpec"
                },
                "status": {
                  "$ref": "#/definitions/v1ClusterStatus"
                }
              },
              "description": "Contains the details of the cluster.\n\nThe `spec` contains the desired details, and may be modified by the user. The `status` contains the current status of\nthe cluster, is provided by the system and can't be modified by the user."
            }
          }
        ],
        "tags": [
          "Clusters"
        ]
      }
    },
    "/api/fulfillment/v1/host_classes": {
      "get": {
        "summary": "Retrieves the list of host classes.",
        "operationId": "HostClasses_List",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1HostClassesListResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "offset",
            "description": "Index of the first result. If not specified the default value will be zero.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "limit",
            "description": "Maximum number of results to be returned by the server. When not specified all the results will be returned. Note\nthat there may not be enough results to return, and that the server may decide, for performance reasons, to return\nless results than requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "filter",
            "description": "Filter criteria.\n\nThe syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names\nof the attributes of the host class instead of the names of the columns of a table. For example, in order to\nretrieve all the host classes with a title starting with `gpu` the value should be:\n\n    title like 'gpu%'\n\nIf this isn't provided, or if the value is empty, then all the host classes that the user has permission to see\nwill be returned.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "order",
            "description": "Order criteria.\n\nThe syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the\nnames of the attributes of the host class instead of the names of the columns of a table. For example, in order to\nsort the templates descending by title the value should be:\n\n    name desc\n\nIf the parameter isn't provided, or if the value is empty, then the order of the results is undefined.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "HostClasses"
        ]
      },
      "post": {
        "summary": "Creates a new host class.",
        "description": "This method isn't allowed for regular users, only for the system itself.",
        "operationId": "HostClasses_Create",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1HostClass"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "object",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1HostClass"
            }
          }
        ],
        "tags": [
          "HostClasses"
        ]
      }
    },
    "/api/fulfillment/v1/host_classes/{id}": {
      "get": {
        "summary": "Retrieves the details of one specific host classes.",
        "operationId": "HostClasses_Get",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1HostClass"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "HostClasses"
        ]
      },
      "delete": {
        "summary": "Delete a host class.",
        "description": "This method isn't allowed for regular users, only for the system itself.",
        "operationId": "HostClasses_Delete",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1HostClassesDeleteResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "HostClasses"
        ]
      }
    },
    "/api/fulfillment/v1/host_classes/{object.id}": {
      "patch": {
        "summary": "Updates an existint host class.",
        "description": "This method isn't allowed for regular users, only for the system itself.",
        "operationId": "HostClasses_Update",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1HostClass"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "object.id",
            "description": "Unique identifier of the class.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "object",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "metadata": {
                  "$ref": "#/definitions/v1Metadata",
                  "description": "Metadata of the host class."
                },
                "title": {
                  "type": "string",
                  "description": "Human friendly short description of the host class, only a few words, suitable for displaying in one single\nline on a UI or CLI."
                },
                "description": {
                  "type": "string",
                  "description": "Human friendly long description of the host class, using Markdown format."
                }
              },
              "description": "Describes a set of hosts that share characteristics.\n\nFor example there could be a host class `acme_1tb` to describe the set of hosts manifactured by ACME and with 1 TiB\nof RAM, and another `ibm_mi300x` to describe the set of hosts manufactured IBM and with a MI300X GPU.\n\nThis is similar to the _instance type_ concept used by many cloud providers.\n\nThe detailed chracteristics of the host (CPU, memory, GPU, etc) will be in the `description` field."
            }
          }
        ],
        "tags": [
          "HostClasses"
        ]
      }
    }
  },
  "definitions": {
    "apiHttpBody": {
      "type": "object",
      "properties": {
        "content_type": {
          "type": "string",
          "description": "The HTTP Content-Type header value specifying the content type of the body."
        },
        "data": {
          "type": "string",
          "format": "byte",
          "description": "The HTTP request/response body as raw binary."
        },
        "extensions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/protobufAny"
          },
          "description": "Application specific response metadata. Must be set in the first response\nfor streaming APIs."
        }
      },
      "description": "Message that represents an arbitrary HTTP body. It should only be used for\npayload formats that can't be represented as JSON, such as raw binary or\nan HTML page.\n\n\nThis message can be used both in streaming and non-streaming API methods in\nthe request as well as the response.\n\nIt can be used as a top-level request field, which is convenient if one\nwants to extract parameters from either the URL or HTTP template into the\nrequest fields and also want access to the raw HTTP body.\n\nExample:\n\n    message GetResourceRequest {\n      // A unique request id.\n      string request_id = 1;\n\n      // The raw HTTP body is bound to this field.\n      google.api.HttpBody http_body = 2;\n\n    }\n\n    service ResourceService {\n      rpc GetResource(GetResourceRequest)\n        returns (google.api.HttpBody);\n      rpc UpdateResource(google.api.HttpBody)\n        returns (google.protobuf.Empty);\n\n    }\n\nExample with streaming methods:\n\n    service CaldavService {\n      rpc GetCalendar(stream google.api.HttpBody)\n        returns (stream google.api.HttpBody);\n      rpc UpdateCalendar(stream google.api.HttpBody)\n        returns (stream google.api.HttpBody);\n\n    }\n\nUse of this type only changes how the request and response bodies are\nhandled, all other features will continue to work unchanged."
    },
    "protobufAny": {
      "type": "object",
      "properties": {
        "@type": {
          "type": "string",
          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
        }
      },
      "additionalProperties": {},
      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(\u0026foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := \u0026pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := \u0026pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": \u003cstring\u003e,\n      \"lastName\": \u003cstring\u003e\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
    },
    "rpcStatus": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/protobufAny"
          }
        }
      }
    },
    "v1Cluster": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier of the cluster."
        },
        "metadata": {
          "$ref": "#/definitions/v1Metadata"
        },
        "spec": {
          "$ref": "#/definitions/v1ClusterSpec"
        },
        "status": {
          "$ref": "#/definitions/v1ClusterStatus"
        }
      },
      "description": "Contains the details of the cluster.\n\nThe `spec` contains the desired details, and may be modified by the user. The `status` contains the current status of\nthe cluster, is provided by the system and can't be modified by the user."
    },
    "v1ClusterCondition": {
      "type": "object",
      "properties": {
        "type": {
          "$ref": "#/definitions/v1ClusterConditionType",
          "description": "Indicates the type of condition."
        },
        "status": {
          "$ref": "#/definitions/v1ConditionStatus",
          "description": "Indicates the status of the condition."
        },
        "last_transition_time": {
          "type": "string",
          "format": "date-time",
          "description": "This time is the last time that the condition was updated."
        },
        "reason": {
          "type": "string",
          "description": "Contains a the reason of the condition in a format suitable for use by programs.\n\nThe possible values will be documented in the object that contains the condition."
        },
        "message": {
          "type": "string",
          "description": "Contains a text giving more details of the condition.\n\nThis will usually be progress reports, or error messages, and are intended for use by humans, to debug problems."
        }
      },
      "description": "Contains the details of a condition that describes the status of a cluster."
    },
    "v1ClusterConditionType": {
      "type": "string",
      "enum": [
        "CLUSTER_CONDITION_TYPE_UNSPECIFIED",
        "CLUSTER_CONDITION_TYPE_PROGRESSING",
        "CLUSTER_CONDITION_TYPE_READY",
        "CLUSTER_CONDITION_TYPE_FAILED",
        "CLUSTER_CONDITION_TYPE_DEGRADED"
      ],
      "default": "CLUSTER_CONDITION_TYPE_UNSPECIFIED",
      "description": "Types of conditions used to describe the status of cluster.\n\n - CLUSTER_CONDITION_TYPE_UNSPECIFIED: Unspecified indicates that the condition is unknown.\n\nThis will never be appear in the `spec.conditions` field of a cluster.\n - CLUSTER_CONDITION_TYPE_PROGRESSING: Indicates that the cluster isn't completely ready yet.\n\nCurrently there are no `reason` values defined.\n - CLUSTER_CONDITION_TYPE_READY: Indicates that the cluster is ready to use.\n\nCurrently there are no `reason` values defined.\n - CLUSTER_CONDITION_TYPE_FAILED: Indicates that the cluster is unusable.\n\nCurrently there are no `reason` values defined.\n - CLUSTER_CONDITION_TYPE_DEGRADED: Indicates that the cluster is degraded."
    },
    "v1ClusterNodeSet": {
      "type": "object",
      "properties": {
        "host_class": {
          "type": "string",
          "description": "Identifier of the class of hosts that are part of the set.\n\nThe details of the host class can be obtained using the `List` and `Get` method of the `HostClasses` service. For\nexample, to get the details of the `acme_1tb` host class using the HTTP+JSON version of the API:\n\n```http\nGET /api/fulfillment/v1/host_classes/acme_1tb\n```\n\nWhich will return something like this:\n\n```json\n{\n  \"id\": \"acme_1tb\",\n  \"title\": \"ACME server with 1 TiB of RAM and no GPU\",\n  \"description\": \"ACME server model XYZ with 1 TiB of RAM, 2 Xeon 6 CPUS and no GPU.\"\n}\n```\n\nThis will be set by the system when the cluster is initially created, according to the template selected by the\nuser.\n\nThe user will not have permission to change this field."
        },
        "size": {
          "type": "integer",
          "format": "int32",
          "description": "Number of nodes of the set."
        }
      },
      "description": "Defines a set of nodes that are part of the cluster, all of them of the same class of host."
    },
    "v1ClusterOrder": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier of the order.\n\nThis will be automatically generated by the system when the order is placed."
        },
        "metadata": {
          "$ref": "#/definitions/v1Metadata"
        },
        "spec": {
          "$ref": "#/definitions/v1ClusterOrderSpec"
        },
        "status": {
          "$ref": "#/definitions/v1ClusterOrderStatus"
        }
      },
      "description": "Contains the details that the user provides to request the provisioning of a cluster, as well as the current status\nof the order provided by the system."
    },
    "v1ClusterOrderCondition": {
      "type": "object",
      "properties": {
        "type": {
          "$ref": "#/definitions/v1ClusterOrderConditionType",
          "description": "Indicates the type of condition."
        },
        "status": {
          "$ref": "#/definitions/v1ConditionStatus",
          "description": "Indicates status of the condition."
        },
        "last_transition_time": {
          "type": "string",
          "format": "date-time",
          "description": "This time is the last time that the condition was updated."
        },
        "reason": {
          "type": "string",
          "description": "Contains a the reason of the condition in a format suitable for use by programs.\n\nThe possible are documented in the `ClusterOrderConditionType` object."
        },
        "message": {
          "type": "string",
          "description": "Contains a text giving more details of the condition. This will usually be progress reports, or error messages, and\nare intended for use by humans, to debug problems."
        }
      },
      "description": "Contains the details of a condition that describes the status of a cluster order."
    },
    "v1ClusterOrderConditionType": {
      "type": "string",
      "enum": [
        "CLUSTER_ORDER_CONDITION_TYPE_UNSPECIFIED",
        "CLUSTER_ORDER_CONDITION_TYPE_ACCEPTED",
        "CLUSTER_ORDER_CONDITION_TYPE_REJECTED",
        "CLUSTER_ORDER_CONDITION_TYPE_CANCELED",
        "CLUSTER_ORDER_CONDITION_TYPE_FULFILLED",
        "CLUSTER_ORDER_CONDITION_TYPE_FAILED"
      ],
      "default": "CLUSTER_ORDER_CONDITION_TYPE_UNSPECIFIED",
      "description": "Types of conditions used to describe a cluster order.\n\n - CLUSTER_ORDER_CONDITION_TYPE_UNSPECIFIED: Unspecified indicates that the condition unknown.\n\nThis will never be appear in the `spec.conditions` field of a order.\n - CLUSTER_ORDER_CONDITION_TYPE_ACCEPTED: Accepted indicates that the order has been accepted by the system.\n - CLUSTER_ORDER_CONDITION_TYPE_REJECTED: Rejected indicates that the order has been rejected by the system, so no further processing will be fulfill it.\n - CLUSTER_ORDER_CONDITION_TYPE_CANCELED: Canceled indicates that the order has been canceled by the user.\n - CLUSTER_ORDER_CONDITION_TYPE_FULFILLED: Fulfilled indicates that the order has been successfully fulfilled.\n\nThe details of the resulting cluster will be available in the `cluster` object indicated by the `status.cluster_id`\nfield.\n - CLUSTER_ORDER_CONDITION_TYPE_FAILED: Failed indicates that fulfillment of the order failed.\n\nCurrently there are no sepcific `reason` values defined."
    },
    "v1ClusterOrderSpec": {
      "type": "object",
      "properties": {
        "template_id": {
          "type": "string",
          "description": "Reference to the cluster template.\n\nThis is mandatory, and must be the value of the `id` field of one of the cluster templates."
        },
        "template_parameters": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/protobufAny"
          },
          "description": "Values of the template parameters.\n\nWhen using the HTTP+JSON version of the API the values must be represented as documented in the (ProtoJSON format\ndocument)[https://protobuf.dev/programming-guides/json]. For example, if the template has a `number_of_nodes`\nparameter of integer type, the complete order should be represented like this:\n\n```json\n{\n  \"template_id\": \"123\",\n  \"template_parameters\": {\n    \"number_of_nodes\": {\n      \"@type\": \"type.googleapis.com/google.protobuf.Int32Value\",\n      \"value\": 42\n    }\n  }\n}\n```\n\nThe possible values of the `@type` are the same as those used by the `type_url` field of the `Any` type:\n\n| Type                           | Value                                             |\n|--------------------------------|---------------------------------------------------|\n| Boolean                        | `type.googleapis.com/google.protobuf.BoolValue`   |\n| Integer number, 32 bits        | `type.googleapis.com/google.protobuf.Int32Value`  |\n| Integer number, 64 bits        | `type.googleapis.com/google.protobuf.Int64Value`  |\n| Floating point number, 32 bits | `type.googleapis.com/google.protobuf.FloatValue`  |\n| Floating point number, 64 bits | `type.googleapis.com/google.protobuf.DoubleValue` |\n| String                         | `type.googleapis.com/google.protobuf.StringValue` |\n| Timestamp                      | `type.googleapis.com/google.protobuf.Timestamp`   |\n| Duration                       | `type.googleapis.com/google.protobuf.Duration`    |\n| Array of bytes                 | `type.googleapis.com/google.protobuf.BytesValue`  |\n| Any JSON value                 | `type.googleapis.com/google.protobuf.Value`       |"
        }
      },
      "description": "Contains the details that the user provides to request the provisioning of the cluster."
    },
    "v1ClusterOrderState": {
      "type": "string",
      "enum": [
        "CLUSTER_ORDER_STATE_UNSPECIFIED",
        "CLUSTER_ORDER_STATE_PROGRESSING",
        "CLUSTER_ORDER_STATE_FULFILLED",
        "CLUSTER_ORDER_STATE_FAILED"
      ],
      "default": "CLUSTER_ORDER_STATE_UNSPECIFIED",
      "description": "Represents the overall state of the order.\n\n - CLUSTER_ORDER_STATE_UNSPECIFIED: Unspecified indicates that the state is unknown.\n - CLUSTER_ORDER_STATE_PROGRESSING: Indicates that the order isn't completelly fulfilled yet.\n - CLUSTER_ORDER_STATE_FULFILLED: Indicates indicates that the order has been successfully fulfilled.\n\nThe details of the resulting cluster will be available in the `cluster` object indicated by the `status.cluster_id`\nfield.\n - CLUSTER_ORDER_STATE_FAILED: Indicates that fulfillment of the order failed."
    },
    "v1ClusterOrderStatus": {
      "type": "object",
      "properties": {
        "state": {
          "$ref": "#/definitions/v1ClusterOrderState",
          "description": "Indicates the overall state of the order.\n\nFor more details check the conditions."
        },
        "conditions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1ClusterOrderCondition"
          },
          "description": "Contains a list of conditions that describe in detail the status of the order.\n\nFor example, an order that failed could be represented like this (when converted to JSON):\n\n   {\n     \"id\": \"123\",\n     \"spec\": {\n       \"template_id\": \"245\"\n     },\n     \"state\": \"CLUSTER_ORDER_STATE_FAILED\",\n     \"status\": {\n       \"conditions\": [\n         {\n           \"type: \"CLUSTER_ORDER_CONDITION_TYPE_ACCEPTED\",\n           \"status\": \"CONDITION_STATUS_TRUE\",\n           \"last_transition_time\": \"2025-03-12 20:15:59+00:00\",\n           \"message\": \"The order has been automatically approved\"\n         },\n         {\n           \"type\": \"CLUSTER_ORDER_CONDITION_TYPE_FULFILLED\",\n           \"status\": \"CONDITION_STATUS_FALSE\",\n           \"last_transition_time\": \"2025-03-12 20:17:16+00:00\"\n         },\n         {\n           \"type\": \"CLUSTER_ORDER_CONDITION_TYPE_FAILED\",\n           \"status\": \"CONDITION_STATUS_TRUE\",\n           \"last_transition_time\": \"2025-03-12 20:18:59+00:00\",\n           \"reason\": \"DnsProvisioningFailure\",\n           \"message\": \"Failed to create DNS domain 'example.com' because it already exists\"\n         }\n       ]\n     }\n   }\n\nIn this example the `ACCEPTED` condition is true. That tells us that the order was accepted, and the details tell\nus that it was automatically approved.\n\nThe `FUFILLED` condition isn't false. That means that order isn't fulfilled, without any other detail.\n\nThe `FAILED` condition is true, so it is telling us that the fulfillment failed. It also gives additional detail\nin the with both a _reason_ intended for use by programs, and some some details to help humans understand and debug\nthe issue.\n\nNote that in this example, to make it shorter, only three conditions appear. In general all the conditions (except\n`UNPSECIFIED`) will appear exactly once.\n\nNote also that this is just an example, in particular the `DnsProvisioningFailure` reason for the failed condition\nis imaginary. Check the documentation of the values of the `ClusterOrderConditionType` enumerated type to see\npossible values for the reason."
        },
        "cluster_id": {
          "type": "string",
          "description": "Reference to the resulting cluster.\n\nThis will be automatically populated by the system when the requested cluster is completely provisoned. Further\ndetails about the cluster, like the API URL, will be available in the corresponding `Cluster` object."
        }
      },
      "description": "Contains the current status of the order."
    },
    "v1ClusterOrdersCreateResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1ClusterOrder"
        }
      }
    },
    "v1ClusterOrdersDeleteResponse": {
      "type": "object"
    },
    "v1ClusterOrdersGetResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1ClusterOrder"
        }
      }
    },
    "v1ClusterOrdersListResponse": {
      "type": "object",
      "properties": {
        "size": {
          "type": "integer",
          "format": "int32",
          "description": "Actual number of items returned. Note that this may be smaller than the value requested in the `limit` parameter\nof the request if there are not enough items, or of the system decides that returning that number of items isn't\nfeasible or convenient for performance reasons."
        },
        "total": {
          "type": "integer",
          "format": "int32",
          "description": "Total number of items of the collection that match the search criteria, regardless of the number of results\nrequested with the `limit` parameter."
        },
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1ClusterOrder"
          },
          "description": "List of results."
        }
      }
    },
    "v1ClusterOrdersUpdateResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1ClusterOrder"
        }
      }
    },
    "v1ClusterSpec": {
      "type": "object",
      "properties": {
        "node_sets": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1ClusterNodeSet"
          },
          "description": "Desired node sets of the cluster.\n\nThis will be automatically set by the system when the cluster is initially created, according to the template\nselected by the user, and can be later modified to change the size.\n\nThe key of the map is the unique identifier of the node set for this cluster.\n\nFor example, a cluster created with two different node sets, one for nodes without GPUs and another for nodes with\nGPUs could be represented like this:\n\n```json\n{\n  \"id\": \"123\",\n  \"spec\": {\n    \"node_sets\": {\n      \"compute\": {\n        \"host_class\": \"acme_1tb\",\n        \"size\": 3\n      },\n      \"gpu\": {\n        \"host_class\": \"acme_1tb_h100\",\n        \"size\": 3\n      }\n    }\n  },\n  \"status\": {\n    \"state\": \"CLUSTER_STATE_READY\",\n    \"node_sets\": {\n      \"compute\": {\n        \"host_class\": \"acme_1tb\",\n        \"size\": 3\n      },\n      \"gpu\": {\n        \"host_class\": \"acme_1tb_h100\",\n        \"size\": 3\n      }\n    }\n  }\n}\n```\n\nThe user will not be allowed to change the `host_class` field.\n\nThe user will not be allowed to remove existing node sets, or add new node sets.\n\nThe user will be allowed to update `size` field.\n\nIf at any time the system can't allocate the number of nodes requested by the user, because of permissions, quota,\navailability of resources or system errors, the cluster will be marked as degraded, and the details will be in the\n`DEGRADED` condition."
        }
      },
      "description": "The spec contains the details of a cluster as desired by the user."
    },
    "v1ClusterState": {
      "type": "string",
      "enum": [
        "CLUSTER_STATE_UNSPECIFIED",
        "CLUSTER_STATE_PROGRESSING",
        "CLUSTER_STATE_READY",
        "CLUSTER_STATE_FAILED"
      ],
      "default": "CLUSTER_STATE_UNSPECIFIED",
      "description": "Represents the overall state of a cluster.\n\n - CLUSTER_STATE_UNSPECIFIED: Unspecified indicates that the state is unknown.\n - CLUSTER_STATE_PROGRESSING: Indicates that the cluster isn't ready yet.\n - CLUSTER_STATE_READY: Indicates indicates that the cluster is ready.\n - CLUSTER_STATE_FAILED: Indicates indicates that the cluster is unusable."
    },
    "v1ClusterStatus": {
      "type": "object",
      "properties": {
        "state": {
          "$ref": "#/definitions/v1ClusterState",
          "description": "Indicates the overall state of the cluster."
        },
        "conditions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1ClusterCondition"
          },
          "description": "Contains a list of conditions that describe in detail the status of the cluster.\n\nFor example, an cluster that is ready could be represented like this (when converted to JSON):\n\n   {\n     \"id\": \"123\",\n     \"spec\": {\n     },\n     \"status\": {\n       \"state\": \"CLUSTER_STATE_READY\",\n       \"conditions\": [\n         {\n           \"type\": \"CLUSTER_CONDITION_TYPE_READY\",\n           \"status\": \"CONDITION_STATUS_TRUE\",\n           \"last_transition_time\": \"2025-03-12 20:15:59+00:00\",\n           \"message\": \"The cluster is ready to use\",\n         },\n         {\n           \"type\": \"CLUSTER_CONDITION_TYPE_FAILED\",\n           \"status\": \"CONDITION_STATUS_FALSE\",\n           \"last_transition_time\": \"2025-03-12 20:10:59+00:00\"\n         }\n       ]\n     }\n   }\n\nIn this example the `READY` condition is true. That tells us that the cluster is ready to use via the API URL\nprovided in the `status.api_url` field.\n\nThe `FAILED` condition is false. That tells us that the cluster is *not* failed.\n\nNote that in this example, to make it shorter, only one condition appears. In general all the conditions (except\n`UNSPECIFIED`) will appear exactly once.\n\nCheck the documentation of the values of the `ClusterConditionType` enumerated type to see possible conditions and\nreasons."
        },
        "api_url": {
          "type": "string",
          "description": "URL of te API server of the cluster.\n\nThis will be empty if the cluster isn't ready."
        },
        "console_url": {
          "type": "string",
          "description": "URL of the console of the cluster.\n\nThis will be empty if the cluster isn't ready or the console isn't enabled."
        },
        "node_sets": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1ClusterNodeSet"
          },
          "description": "Current node sets of the cluster.\n\nThis is the current status of the node sets. It will be different to `spec.node_sets` when there is a change that\nis in progress, or if the system can't apply the changes requested by the user.\n\nThe key of the map is the unique identifier of the node set for this cluster."
        }
      },
      "description": "The status contains the details of the cluster provided by the system."
    },
    "v1ClusterTemplate": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier of the template."
        },
        "metadata": {
          "$ref": "#/definitions/v1Metadata"
        },
        "title": {
          "type": "string",
          "description": "Human friendly short description of the template, only a few words, suitable for displaying in one single\nline on a UI or CLI."
        },
        "description": {
          "type": "string",
          "description": "Human friendly long description of the template, using Markdown format."
        },
        "parameters": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1ClusterTemplateParameterDefinition"
          },
          "description": "Definitions of the parameters that can be used to customize the template.\n\nNote that these are only the *definitions* of the parameters, not the actual values. The actual values are in the\n`spec.template_parameters` field of the cluster order."
        }
      },
      "description": "A cluster template defines a type of cluster that can be ordered by the user. Note that the user doesn't create these\ntemplates: the system provides a collection of them, and the user chooses one."
    },
    "v1ClusterTemplateParameterDefinition": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Name of the parameter.\n\nThis is the name that should be used in the `template_parameters` field of the order to assign a value to the\nparameter."
        },
        "title": {
          "type": "string",
          "description": "Human friendly short description of the parameter, only a few words, suitable for displaying in one single line on\na UI or CLI."
        },
        "description": {
          "type": "string",
          "description": "Human friendly description of the parameter, using Markdown format."
        },
        "required": {
          "type": "boolean",
          "description": "Indicates if this parameter is required or optional.\n\nValues for required parameters must be included when sending the order, otherwise it will be rejected.\n\nNote that there may be other dependencies between parameters which may cause a order to be rejected. For example,\nthe allowed values of a parameter may depend on the value of another parameter. That kind of information will be in\nthe `description` field."
        },
        "type": {
          "type": "string",
          "description": "Type of the parameter.\n\nThe possible values are the same as those used by the `type_url` field of the `Any` type:\n\n| Type                           | Value                                             |\n|--------------------------------|---------------------------------------------------|\n| Boolean                        | `type.googleapis.com/google.protobuf.BoolValue`   |\n| Integer number, 32 bits        | `type.googleapis.com/google.protobuf.Int32Value`  |\n| Integer number, 64 bits        | `type.googleapis.com/google.protobuf.Int64Value`  |\n| Floating point number, 32 bits | `type.googleapis.com/google.protobuf.FloatValue`  |\n| Floating point number, 64 bits | `type.googleapis.com/google.protobuf.DoubleValue` |\n| String                         | `type.googleapis.com/google.protobuf.StringValue` |\n| Timestamp                      | `type.googleapis.com/google.protobuf.Timestamp`   |\n| Duration                       | `type.googleapis.com/google.protobuf.Duration`    |\n| Array of bytes                 | `type.googleapis.com/google.protobuf.BytesValue`  |\n| Any JSON value                 | `type.googleapis.com/google.protobuf.Value`       |\n\nWhen using the HTTP+JSON version of the API the value provided in the `template_parameters` field of the order\nmust be represented as documented in the (ProtoJSON format document)[https://protobuf.dev/programming-guides/json]."
        },
        "default": {
          "$ref": "#/definitions/protobufAny",
          "description": "Default value for optional parameters."
        }
      },
      "description": "Contains type and documentation of a template parameter."
    },
    "v1ClusterTemplatesCreateResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1ClusterTemplate"
        }
      }
    },
    "v1ClusterTemplatesDeleteResponse": {
      "type": "object"
    },
    "v1ClusterTemplatesGetResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1ClusterTemplate"
        }
      }
    },
    "v1ClusterTemplatesListResponse": {
      "type": "object",
      "properties": {
        "size": {
          "type": "integer",
          "format": "int32",
          "description": "Actual number of items returned. Note that this may be smaller than the value requested in the `limit` parameter\nof the request if there are not enough items, or of the system decides that returning that number of items isn't\nfeasible or convenient for performance reasons."
        },
        "total": {
          "type": "integer",
          "format": "int32",
          "description": "Total number of items of the collection that match the search criteria, regardless of the number of results\nrequested with the `limit` parameter."
        },
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1ClusterTemplate"
          },
          "description": "List of results."
        }
      }
    },
    "v1ClusterTemplatesUpdateResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1ClusterTemplate"
        }
      }
    },
    "v1ClustersCreateResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1Cluster"
        }
      }
    },
    "v1ClustersDeleteResponse": {
      "type": "object"
    },
    "v1ClustersGetKubeconfigResponse": {
      "type": "object",
      "properties": {
        "kubeconfig": {
          "type": "string"
        }
      }
    },
    "v1ClustersGetResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1Cluster"
        }
      }
    },
    "v1ClustersListResponse": {
      "type": "object",
      "properties": {
        "size": {
          "type": "integer",
          "format": "int32",
          "description": "Actual number of items returned. Note that this may be smaller than the value requested in the `limit` parameter\nof the request if there are not enough items, or of the system decides that returning that number of items isn't\nfeasible or convenient for performance reasons."
        },
        "total": {
          "type": "integer",
          "format": "int32",
          "description": "Total number of items of the collection that match the search criteria, regardless of the number of results\nrequested with the `limit` parameter."
        },
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Cluster"
          },
          "description": "List of results."
        }
      }
    },
    "v1ClustersUpdateResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1Cluster"
        },
        "update_mask": {
          "type": "string"
        }
      }
    },
    "v1ConditionStatus": {
      "type": "string",
      "enum": [
        "CONDITION_STATUS_UNSPECIFIED",
        "CONDITION_STATUS_TRUE",
        "CONDITION_STATUS_FALSE"
      ],
      "default": "CONDITION_STATUS_UNSPECIFIED",
      "description": " - CONDITION_STATUS_UNSPECIFIED: Indicates that the system can't decide if the object is in the condition or not.\n - CONDITION_STATUS_TRUE: Indicates that the object is in the condition.\n - CONDITION_STATUS_FALSE: Indicates that the object is not in the condition."
    },
    "v1Event": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier of the event."
        },
        "type": {
          "$ref": "#/definitions/v1EventType",
          "description": "Type of event."
        },
        "cluster": {
          "$ref": "#/definitions/v1Cluster"
        },
        "cluster_order": {
          "$ref": "#/definitions/v1ClusterOrder"
        },
        "cluster_template": {
          "$ref": "#/definitions/v1ClusterTemplate"
        }
      },
      "description": "Represents events delivered by the server."
    },
    "v1EventType": {
      "type": "string",
      "enum": [
        "EVENT_TYPE_UNSPECIFIED",
        "EVENT_TYPE_OBJECT_CREATED",
        "EVENT_TYPE_OBJECT_UPDATED",
        "EVENT_TYPE_OBJECT_DELETED"
      ],
      "default": "EVENT_TYPE_UNSPECIFIED",
      "description": " - EVENT_TYPE_UNSPECIFIED: Unspecified means that the even type is unknown.\n - EVENT_TYPE_OBJECT_CREATED: Means that a new object has been created.\n\nThe payload will contain the representation of the object.\n - EVENT_TYPE_OBJECT_UPDATED: Means that an existing object has been modified.\n\nThe payload will contain the updated representation of the object.\n - EVENT_TYPE_OBJECT_DELETED: Means that an object has been deleted.\n\nThe payload will contain the representation of the object right before it was deleted."
    },
    "v1EventsWatchResponse": {
      "type": "object",
      "properties": {
        "event": {
          "$ref": "#/definitions/v1Event"
        }
      }
    },
    "v1HostClass": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier of the class."
        },
        "metadata": {
          "$ref": "#/definitions/v1Metadata",
          "description": "Metadata of the host class."
        },
        "title": {
          "type": "string",
          "description": "Human friendly short description of the host class, only a few words, suitable for displaying in one single\nline on a UI or CLI."
        },
        "description": {
          "type": "string",
          "description": "Human friendly long description of the host class, using Markdown format."
        }
      },
      "description": "Describes a set of hosts that share characteristics.\n\nFor example there could be a host class `acme_1tb` to describe the set of hosts manifactured by ACME and with 1 TiB\nof RAM, and another `ibm_mi300x` to describe the set of hosts manufactured IBM and with a MI300X GPU.\n\nThis is similar to the _instance type_ concept used by many cloud providers.\n\nThe detailed chracteristics of the host (CPU, memory, GPU, etc) will be in the `description` field."
    },
    "v1HostClassesCreateResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1HostClass"
        }
      }
    },
    "v1HostClassesDeleteResponse": {
      "type": "object"
    },
    "v1HostClassesGetResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1HostClass"
        }
      }
    },
    "v1HostClassesListResponse": {
      "type": "object",
      "properties": {
        "size": {
          "type": "integer",
          "format": "int32",
          "description": "Actual number of items returned. Note that this may be smaller than the value requested in the `limit` parameter\nof the request if there are not enough items, or of the system decides that returning that number of items isn't\nfeasible or convenient for performance reasons."
        },
        "total": {
          "type": "integer",
          "format": "int32",
          "description": "Total number of items of the collection that match the search criteria, regardless of the number of results\nrequested with the `limit` parameter."
        },
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1HostClass"
          },
          "description": "List of results."
        }
      }
    },
    "v1HostClassesUpdateResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1HostClass"
        }
      }
    },
    "v1Metadata": {
      "type": "object",
      "properties": {
        "creation_timestamp": {
          "type": "string",
          "format": "date-time",
          "description": "Time of creation of the object."
        },
        "deletion_timestamp": {
          "type": "string",
          "format": "date-time",
          "description": "Time of deletion of the object."
        }
      },
      "description": "Metadata common to all kinds of objects."
    }
  }
}
